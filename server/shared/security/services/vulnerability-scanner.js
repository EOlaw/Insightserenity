// server/shared/security/services/vulnerability-scanner.js
/**
 * @file Vulnerability Scanner Service
 * @description Security vulnerability detection and monitoring
 * @version 3.0.0
 */

const mongoose = require('mongoose');
const logger = require('../../utils/logger');
const config = require('../../config');
const AuditService = require('./audit-service');
const { AppError } = require('../../utils/app-error');

/**
 * Vulnerability Schema
 */
const vulnerabilitySchema = new mongoose.Schema({
  identifier: {
    type: String,
    required: true,
    unique: true
  },
  
  type: {
    type: String,
    enum: ['dependency', 'code', 'configuration', 'infrastructure', 'api', 'authentication'],
    required: true
  },
  
  severity: {
    type: String,
    enum: ['low', 'medium', 'high', 'critical'],
    required: true
  },
  
  status: {
    type: String,
    enum: ['open', 'acknowledged', 'in_progress', 'resolved', 'false_positive'],
    default: 'open'
  },
  
  details: {
    title: String,
    description: String,
    affectedComponent: String,
    affectedVersion: String,
    cve: String,
    cvss: {
      score: Number,
      vector: String
    },
    references: [String]
  },
  
  detection: {
    method: String,
    scanner: String,
    timestamp: Date,
    confidence: Number
  },
  
  impact: {
    confidentiality: String,
    integrity: String,
    availability: String,
    scope: String,
    exploitability: String
  },
  
  remediation: {
    description: String,
    effort: String,
    fixVersion: String,
    workaround: String,
    patch: String
  },
  
  tracking: {
    reportedBy: String,
    assignedTo: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    acknowledgedAt: Date,
    resolvedAt: Date,
    resolvedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    notes: [{
      author: { type: mongoose.Schema.Types.ObjectId, ref: 'User' },
      content: String,
      timestamp: { type: Date, default: Date.now }
    }]
  },
  
  metadata: {
    organizationId: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'Organization'
    },
    environment: String,
    service: String,
    tags: [String]
  }
}, {
  timestamps: true
});

// Indexes
vulnerabilitySchema.index({ type: 1, severity: 1, status: 1 });
vulnerabilitySchema.index({ 'details.cve': 1 });
vulnerabilitySchema.index({ createdAt: -1, severity: 1 });

const Vulnerability = mongoose.model('Vulnerability', vulnerabilitySchema);

/**
 * Vulnerability Scanner Service Class
 * @class VulnerabilityScanner
 */
class VulnerabilityScanner {
  constructor() {
    this.scanners = new Map();
    this.thresholds = {
      critical: { sla: 24, autoEscalate: true }, // 24 hours
      high: { sla: 72, autoEscalate: true }, // 3 days
      medium: { sla: 168, autoEscalate: false }, // 7 days
      low: { sla: 720, autoEscalate: false } // 30 days
    };
    
    this.initializeScanners();
  }
  
  /**
   * Initialize security scanners
   */
  initializeScanners() {
    // Register built-in scanners
    this.registerScanner('auth', this.createAuthScanner());
    this.registerScanner('session', this.createSessionScanner());
    this.registerScanner('input', this.createInputScanner());
    this.registerScanner('api', this.createAPIScanner());
    this.registerScanner('dependency', this.createDependencyScanner());
    this.registerScanner('configuration', this.createConfigScanner());
  }
  
  /**
   * Register a vulnerability scanner
   * @param {string} name - Scanner name
   * @param {Object} scanner - Scanner implementation
   */
  registerScanner(name, scanner) {
    this.scanners.set(name, scanner);
    logger.info(`Vulnerability scanner registered: ${name}`);
  }
  
  /**
   * Run security scan
   * @param {Object} options - Scan options
   * @returns {Promise<Object>} Scan results
   */
  async scan(options = {}) {
    const {
      scanners = Array.from(this.scanners.keys()),
      environment = config.env,
      organizationId = null
    } = options;
    
    const results = {
      timestamp: new Date(),
      environment,
      scanners: {},
      summary: {
        total: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        new: 0
      }
    };
    
    try {
      // Run selected scanners
      for (const scannerName of scanners) {
        const scanner = this.scanners.get(scannerName);
        
        if (!scanner) {
          logger.warn(`Scanner not found: ${scannerName}`);
          continue;
        }
        
        try {
          const scanResults = await scanner.scan({ environment, organizationId });
          results.scanners[scannerName] = scanResults;
          
          // Process vulnerabilities
          for (const vuln of scanResults.vulnerabilities) {
            await this.processVulnerability(vuln, scannerName);
            
            results.summary.total++;
            results.summary[vuln.severity]++;
            if (vuln.isNew) results.summary.new++;
          }
        } catch (error) {
          logger.error(`Scanner ${scannerName} failed`, { error });
          results.scanners[scannerName] = { error: error.message };
        }
      }
      
      // Log scan completion
      await AuditService.log({
        type: 'vulnerability_scan',
        action: 'security_scan_completed',
        category: 'security',
        result: 'success',
        target: {
          type: 'system',
          id: environment
        },
        metadata: {
          scanners: scanners.join(','),
          vulnerabilities: results.summary
        }
      });
      
      return results;
    } catch (error) {
      logger.error('Vulnerability scan failed', { error });
      throw new AppError('Security scan failed', 500, 'SCAN_ERROR');
    }
  }
  
  /**
   * Process detected vulnerability
   * @param {Object} vuln - Vulnerability data
   * @param {string} scanner - Scanner name
   * @returns {Promise<Vulnerability>} Processed vulnerability
   */
  async processVulnerability(vuln, scanner) {
    try {
      // Generate unique identifier
      const identifier = this.generateIdentifier(vuln, scanner);
      
      // Check if vulnerability already exists
      let vulnerability = await Vulnerability.findOne({ identifier });
      
      if (vulnerability) {
        // Update existing vulnerability
        if (vulnerability.status === 'resolved') {
          // Regression detected
          vulnerability.status = 'open';
          vulnerability.tracking.notes.push({
            content: 'Vulnerability regression detected',
            timestamp: new Date()
          });
          
          // Alert security team
          await this.alertSecurityTeam({
            type: 'regression',
            vulnerability
          });
        }
        
        vulnerability.detection.timestamp = new Date();
        await vulnerability.save();
        
        vuln.isNew = false;
      } else {
        // Create new vulnerability
        vulnerability = await Vulnerability.create({
          identifier,
          type: vuln.type,
          severity: vuln.severity,
          details: vuln.details,
          detection: {
            method: scanner,
            scanner: vuln.scanner || scanner,
            timestamp: new Date(),
            confidence: vuln.confidence || 100
          },
          impact: vuln.impact,
          remediation: vuln.remediation,
          metadata: vuln.metadata
        });
        
        vuln.isNew = true;
        
        // Check if immediate action required
        if (vuln.severity === 'critical' || vuln.severity === 'high') {
          await this.alertSecurityTeam({
            type: 'new_vulnerability',
            vulnerability
          });
        }
      }
      
      return vulnerability;
    } catch (error) {
      logger.error('Failed to process vulnerability', { error, vuln });
      throw error;
    }
  }
  
  /**
   * Create authentication scanner
   * @returns {Object} Scanner implementation
   */
  createAuthScanner() {
    return {
      name: 'Authentication Scanner',
      scan: async ({ environment }) => {
        const vulnerabilities = [];
        
        // Check for weak password policies
        if (config.security.password.minLength < 12) {
          vulnerabilities.push({
            type: 'authentication',
            severity: 'medium',
            details: {
              title: 'Weak Password Policy',
              description: 'Password minimum length is less than 12 characters',
              affectedComponent: 'Authentication System'
            },
            remediation: {
              description: 'Increase minimum password length to 12 or more characters',
              effort: 'low'
            }
          });
        }
        
        // Check for missing 2FA enforcement
        if (!config.features.twoFactorAuth) {
          vulnerabilities.push({
            type: 'authentication',
            severity: 'high',
            details: {
              title: 'Two-Factor Authentication Not Enforced',
              description: '2FA is not mandatory for all users',
              affectedComponent: 'Authentication System'
            },
            remediation: {
              description: 'Enable and enforce 2FA for all user accounts',
              effort: 'medium'
            }
          });
        }
        
        // Check for excessive login attempts
        const failedLogins = await this.checkFailedLogins();
        if (failedLogins.suspicious.length > 0) {
          vulnerabilities.push({
            type: 'authentication',
            severity: 'high',
            details: {
              title: 'Suspicious Login Activity Detected',
              description: `${failedLogins.suspicious.length} IPs with excessive failed login attempts`,
              affectedComponent: 'Login System'
            },
            impact: {
              confidentiality: 'high',
              integrity: 'none',
              availability: 'low'
            },
            metadata: {
              suspiciousIPs: failedLogins.suspicious
            }
          });
        }
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Create session scanner
   * @returns {Object} Scanner implementation
   */
  createSessionScanner() {
    return {
      name: 'Session Scanner',
      scan: async () => {
        const vulnerabilities = [];
        
        // Check session configuration
        if (!config.auth.sessionSecret || config.auth.sessionSecret === 'your-session-secret') {
          vulnerabilities.push({
            type: 'configuration',
            severity: 'critical',
            details: {
              title: 'Insecure Session Secret',
              description: 'Session secret is using default or weak value',
              affectedComponent: 'Session Management'
            },
            remediation: {
              description: 'Generate and use a strong, random session secret',
              effort: 'low'
            }
          });
        }
        
        // Check for session fixation vulnerabilities
        if (!config.security.sessionRotationMinutes) {
          vulnerabilities.push({
            type: 'authentication',
            severity: 'medium',
            details: {
              title: 'Session Fixation Risk',
              description: 'Sessions are not rotated periodically',
              affectedComponent: 'Session Management'
            },
            remediation: {
              description: 'Implement session rotation on privilege changes',
              effort: 'medium'
            }
          });
        }
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Create input validation scanner
   * @returns {Object} Scanner implementation
   */
  createInputScanner() {
    return {
      name: 'Input Validation Scanner',
      scan: async () => {
        const vulnerabilities = [];
        
        // This would analyze routes and check for validation
        // Placeholder implementation
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Create API security scanner
   * @returns {Object} Scanner implementation
   */
  createAPIScanner() {
    return {
      name: 'API Security Scanner',
      scan: async () => {
        const vulnerabilities = [];
        
        // Check for missing rate limiting
        if (!config.security.rateLimiting.max) {
          vulnerabilities.push({
            type: 'api',
            severity: 'high',
            details: {
              title: 'Missing API Rate Limiting',
              description: 'API endpoints are not protected by rate limiting',
              affectedComponent: 'API Gateway'
            },
            remediation: {
              description: 'Implement rate limiting for all API endpoints',
              effort: 'medium'
            }
          });
        }
        
        // Check for API versioning
        if (!config.server.apiPrefix.includes('v')) {
          vulnerabilities.push({
            type: 'api',
            severity: 'low',
            details: {
              title: 'Missing API Versioning',
              description: 'API does not implement versioning',
              affectedComponent: 'API Gateway'
            },
            remediation: {
              description: 'Implement API versioning strategy',
              effort: 'high'
            }
          });
        }
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Create dependency scanner
   * @returns {Object} Scanner implementation
   */
  createDependencyScanner() {
    return {
      name: 'Dependency Scanner',
      scan: async () => {
        const vulnerabilities = [];
        
        // This would integrate with npm audit or similar
        // Placeholder implementation
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Create configuration scanner
   * @returns {Object} Scanner implementation
   */
  createConfigScanner() {
    return {
      name: 'Configuration Scanner',
      scan: async () => {
        const vulnerabilities = [];
        
        // Check for development settings in production
        if (config.isProduction) {
          if (config.logging.level === 'debug') {
            vulnerabilities.push({
              type: 'configuration',
              severity: 'medium',
              details: {
                title: 'Debug Logging in Production',
                description: 'Debug logging is enabled in production environment',
                affectedComponent: 'Logging System'
              },
              remediation: {
                description: 'Set logging level to "error" or "warn" in production',
                effort: 'low'
              }
            });
          }
          
          if (!config.security.encryption.enabled) {
            vulnerabilities.push({
              type: 'configuration',
              severity: 'high',
              details: {
                title: 'Encryption Disabled',
                description: 'Data encryption is not enabled',
                affectedComponent: 'Data Storage'
              },
              remediation: {
                description: 'Enable encryption for sensitive data',
                effort: 'medium'
              }
            });
          }
        }
        
        return { vulnerabilities };
      }
    };
  }
  
  /**
   * Generate unique vulnerability identifier
   * @param {Object} vuln - Vulnerability data
   * @param {string} scanner - Scanner name
   * @returns {string} Unique identifier
   */
  generateIdentifier(vuln, scanner) {
    const components = [
      scanner,
      vuln.type,
      vuln.details.affectedComponent,
      vuln.details.title
    ].filter(Boolean);
    
    return components
      .join(':')
      .toLowerCase()
      .replace(/[^a-z0-9:]/g, '_');
  }
  
  /**
   * Check for failed login attempts
   * @returns {Promise<Object>} Failed login analysis
   */
  async checkFailedLogins() {
    // This would query audit logs for failed login attempts
    // Placeholder implementation
    return {
      total: 0,
      suspicious: []
    };
  }
  
  /**
   * Alert security team
   * @param {Object} alert - Alert details
   */
  async alertSecurityTeam(alert) {
    logger.warn('Security Alert', alert);
    
    // This would send notifications to security team
    // Implementation depends on notification service
  }
  
  /**
   * Get vulnerability statistics
   * @param {Object} filters - Query filters
   * @returns {Promise<Object>} Statistics
   */
  async getStatistics(filters = {}) {
    const query = {};
    
    if (filters.status) {
      query.status = filters.status;
    }
    
    if (filters.severity) {
      query.severity = filters.severity;
    }
    
    if (filters.type) {
      query.type = filters.type;
    }
    
    const [total, bySeverity, byStatus, byType, overdue] = await Promise.all([
      Vulnerability.countDocuments(query),
      Vulnerability.aggregate([
        { $match: query },
        { $group: { _id: '$severity', count: { $sum: 1 } } }
      ]),
      Vulnerability.aggregate([
        { $match: query },
        { $group: { _id: '$status', count: { $sum: 1 } } }
      ]),
      Vulnerability.aggregate([
        { $match: query },
        { $group: { _id: '$type', count: { $sum: 1 } } }
      ]),
      this.getOverdueVulnerabilities()
    ]);
    
    return {
      total,
      bySeverity: this.arrayToObject(bySeverity),
      byStatus: this.arrayToObject(byStatus),
      byType: this.arrayToObject(byType),
      overdue: overdue.length,
      meanTimeToResolve: await this.calculateMTTR(query)
    };
  }
  
  /**
   * Get overdue vulnerabilities
   * @returns {Promise<Array>} Overdue vulnerabilities
   */
  async getOverdueVulnerabilities() {
    const overdue = [];
    
    for (const [severity, config] of Object.entries(this.thresholds)) {
      const deadline = new Date();
      deadline.setHours(deadline.getHours() - config.sla);
      
      const vulns = await Vulnerability.find({
        severity,
        status: { $in: ['open', 'acknowledged'] },
        createdAt: { $lt: deadline }
      });
      
      overdue.push(...vulns);
    }
    
    return overdue;
  }
  
  /**
   * Calculate mean time to resolve
   * @param {Object} query - Query filter
   * @returns {Promise<number>} MTTR in hours
   */
  async calculateMTTR(query) {
    const resolved = await Vulnerability.find({
      ...query,
      status: 'resolved',
      'tracking.resolvedAt': { $exists: true }
    });
    
    if (resolved.length === 0) return 0;
    
    const totalTime = resolved.reduce((sum, vuln) => {
      const timeToResolve = vuln.tracking.resolvedAt - vuln.createdAt;
      return sum + timeToResolve;
    }, 0);
    
    return Math.round(totalTime / resolved.length / (1000 * 60 * 60)); // Convert to hours
  }
  
  /**
   * Convert array of objects to object
   * @param {Array} arr - Array of { _id, count } objects
   * @returns {Object} Object with _id as keys
   */
  arrayToObject(arr) {
    return arr.reduce((obj, item) => {
      obj[item._id] = item.count;
      return obj;
    }, {});
  }
}

// Create and export singleton instance
module.exports = new VulnerabilityScanner();